/**
 *@addtogroup grp_complexnumbers
 *@about 
 *Implementation of a user-defined Complex type.
 *@par Related Topics
 *
 *File complex_type.sql_in, source file for all overloaded forms of the SQL functions
 */

CREATE TYPE DSTOOLS_SCHEMA.complex;

CREATE FUNCTION DSTOOLS_SCHEMA.complex_in(cstring) RETURNS DSTOOLS_SCHEMA.complex LANGUAGE C IMMUTABLE STRICT 
	AS  'MODULE_PATHNAME','complex_in';
COMMENT ON FUNCTION DSTOOLS_SCHEMA.complex_in(cstring)  IS 'IO';

CREATE FUNCTION DSTOOLS_SCHEMA.complex_out(DSTOOLS_SCHEMA.complex) RETURNS cstring LANGUAGE C IMMUTABLE STRICT 
	AS  'MODULE_PATHNAME','complex_out';
COMMENT ON FUNCTION DSTOOLS_SCHEMA.complex_out(DSTOOLS_SCHEMA.complex)  IS 'IO';

CREATE FUNCTION DSTOOLS_SCHEMA.complex_recv(internal) RETURNS DSTOOLS_SCHEMA.complex LANGUAGE C IMMUTABLE STRICT 
	AS  'MODULE_PATHNAME','complex_recv';
COMMENT ON FUNCTION DSTOOLS_SCHEMA.complex_recv(internal)  IS 'IO';

CREATE FUNCTION DSTOOLS_SCHEMA.complex_send(DSTOOLS_SCHEMA.complex) RETURNS bytea LANGUAGE C IMMUTABLE STRICT 
	AS  'MODULE_PATHNAME','complex_send' ;
COMMENT ON FUNCTION DSTOOLS_SCHEMA.complex_send(DSTOOLS_SCHEMA.complex)  IS 'IO';

CREATE TYPE DSTOOLS_SCHEMA.complex(
   INPUT = DSTOOLS_SCHEMA.complex_in,
   OUTPUT = DSTOOLS_SCHEMA.complex_out,
   RECEIVE = DSTOOLS_SCHEMA.complex_recv,
   SEND = DSTOOLS_SCHEMA.complex_send,
   INTERNALLENGTH = 16,
   STORAGE = plain,
   ALIGNMENT = double
);
COMMENT ON TYPE DSTOOLS_SCHEMA.complex IS 'double-precision floating point complex number, 16-byte storage';

---------------------------------------------------------------
-- Constructors and Operators on Complex Numbers
----------------------------------------------------------------

CREATE FUNCTION DSTOOLS_SCHEMA.complex(re float8, im float8) RETURNS DSTOOLS_SCHEMA.complex LANGUAGE C IMMUTABLE STRICT
AS  'MODULE_PATHNAME','construct_complex'; 
COMMENT ON FUNCTION DSTOOLS_SCHEMA.complex(float8, float8)  IS 'constructs a complex number with given magnitude and phase';

CREATE FUNCTION DSTOOLS_SCHEMA.complex_trig(re float8, im float8) RETURNS DSTOOLS_SCHEMA.complex LANGUAGE C IMMUTABLE STRICT 
	AS  'MODULE_PATHNAME','construct_complex_trig';
COMMENT ON FUNCTION DSTOOLS_SCHEMA.complex_trig(float8, float8)  IS 'constructs a complex number with given magnitude and phase';

CREATE FUNCTION DSTOOLS_SCHEMA.re(cmplx DSTOOLS_SCHEMA.complex) RETURNS float8 LANGUAGE C IMMUTABLE STRICT 
	AS  'MODULE_PATHNAME','complex_re' ;
COMMENT ON FUNCTION DSTOOLS_SCHEMA.re(DSTOOLS_SCHEMA.complex)  IS 'returns the real part of the argument';

CREATE FUNCTION DSTOOLS_SCHEMA.im(cmplx DSTOOLS_SCHEMA.complex) RETURNS float8 LANGUAGE C IMMUTABLE STRICT 
	AS  'MODULE_PATHNAME','complex_im';
COMMENT ON FUNCTION DSTOOLS_SCHEMA.im(DSTOOLS_SCHEMA.complex)  IS 'returns the imaginary part of the argument';

CREATE FUNCTION DSTOOLS_SCHEMA.radians(cmplx DSTOOLS_SCHEMA.complex) RETURNS float8 LANGUAGE C IMMUTABLE STRICT 
	AS  'MODULE_PATHNAME','complex_arg' ;
COMMENT ON FUNCTION DSTOOLS_SCHEMA.radians(DSTOOLS_SCHEMA.complex)  IS 'returns the phase of the argument';

CREATE FUNCTION DSTOOLS_SCHEMA.complexabs(cmplx DSTOOLS_SCHEMA.complex) RETURNS float8 LANGUAGE C IMMUTABLE STRICT 
	AS  'MODULE_PATHNAME','complex_mag' ;
COMMENT ON FUNCTION DSTOOLS_SCHEMA.complexabs(DSTOOLS_SCHEMA.complex)  IS 'returns the magnitude of the argument';

CREATE FUNCTION DSTOOLS_SCHEMA.abs(cmplx DSTOOLS_SCHEMA.complex) RETURNS float8 LANGUAGE C IMMUTABLE STRICT 
	AS  'MODULE_PATHNAME','complex_mag';
COMMENT ON FUNCTION DSTOOLS_SCHEMA.abs(DSTOOLS_SCHEMA.complex)  IS 'returns the magnitude of the argument';

CREATE FUNCTION DSTOOLS_SCHEMA.conj(cmplx DSTOOLS_SCHEMA.complex) RETURNS DSTOOLS_SCHEMA.complex LANGUAGE C IMMUTABLE STRICT 
	AS  'MODULE_PATHNAME','complex_conj' ;
COMMENT ON FUNCTION DSTOOLS_SCHEMA.conj(DSTOOLS_SCHEMA.complex)  IS 'returns the conjunction of the argument';

CREATE FUNCTION DSTOOLS_SCHEMA.complex_eq(cmplx_a DSTOOLS_SCHEMA.complex, cmplx_b DSTOOLS_SCHEMA.complex) RETURNS bool  LANGUAGE C IMMUTABLE STRICT 
	AS  'MODULE_PATHNAME','complex_eq' ;
COMMENT ON FUNCTION DSTOOLS_SCHEMA.complex_eq(DSTOOLS_SCHEMA.complex, DSTOOLS_SCHEMA.complex)  IS 'equal';

CREATE FUNCTION DSTOOLS_SCHEMA.complex_ne(DSTOOLS_SCHEMA.complex, DSTOOLS_SCHEMA.complex) RETURNS bool  LANGUAGE C IMMUTABLE STRICT 
	AS  'MODULE_PATHNAME','complex_ne';
COMMENT ON FUNCTION DSTOOLS_SCHEMA.complex_ne(DSTOOLS_SCHEMA.complex, DSTOOLS_SCHEMA.complex)  IS 'not equal';

CREATE FUNCTION DSTOOLS_SCHEMA.complex_pl(DSTOOLS_SCHEMA.complex, DSTOOLS_SCHEMA.complex) RETURNS DSTOOLS_SCHEMA.complex LANGUAGE C IMMUTABLE STRICT 
	AS  'MODULE_PATHNAME','complex_pl';
COMMENT ON FUNCTION DSTOOLS_SCHEMA.complex_pl(DSTOOLS_SCHEMA.complex, DSTOOLS_SCHEMA.complex)  IS 'plus';

CREATE FUNCTION DSTOOLS_SCHEMA.complex_up(DSTOOLS_SCHEMA.complex) RETURNS DSTOOLS_SCHEMA.complex LANGUAGE C IMMUTABLE STRICT 
	AS  'MODULE_PATHNAME','complex_up';
COMMENT ON FUNCTION DSTOOLS_SCHEMA.complex_up(DSTOOLS_SCHEMA.complex)  IS 'unary plus';

CREATE FUNCTION DSTOOLS_SCHEMA.complex_mi(DSTOOLS_SCHEMA.complex, DSTOOLS_SCHEMA.complex) RETURNS DSTOOLS_SCHEMA.complex LANGUAGE C IMMUTABLE STRICT 
	AS  'MODULE_PATHNAME','complex_mi' ;
COMMENT ON FUNCTION DSTOOLS_SCHEMA.complex_mi(DSTOOLS_SCHEMA.complex, DSTOOLS_SCHEMA.complex)  IS 'minus';

CREATE FUNCTION DSTOOLS_SCHEMA.complex_um(DSTOOLS_SCHEMA.complex) RETURNS DSTOOLS_SCHEMA.complex LANGUAGE C IMMUTABLE STRICT 
	AS  'MODULE_PATHNAME','complex_um';
COMMENT ON FUNCTION DSTOOLS_SCHEMA.complex_um(DSTOOLS_SCHEMA.complex)  IS 'unary minus';

CREATE FUNCTION DSTOOLS_SCHEMA.complex_mul(DSTOOLS_SCHEMA.complex, DSTOOLS_SCHEMA.complex) RETURNS DSTOOLS_SCHEMA.complex LANGUAGE C IMMUTABLE STRICT 
	AS  'MODULE_PATHNAME','complex_mul';
COMMENT ON FUNCTION DSTOOLS_SCHEMA.complex_mul(DSTOOLS_SCHEMA.complex, DSTOOLS_SCHEMA.complex)  IS 'multiply';

CREATE FUNCTION DSTOOLS_SCHEMA.complex_div(DSTOOLS_SCHEMA.complex, DSTOOLS_SCHEMA.complex) RETURNS DSTOOLS_SCHEMA.complex LANGUAGE C IMMUTABLE STRICT 
	AS  'MODULE_PATHNAME','complex_div';
COMMENT ON FUNCTION DSTOOLS_SCHEMA.complex_div(DSTOOLS_SCHEMA.complex, DSTOOLS_SCHEMA.complex)  IS 'divide';

CREATE FUNCTION DSTOOLS_SCHEMA.complex_power(DSTOOLS_SCHEMA.complex, DSTOOLS_SCHEMA.complex) RETURNS DSTOOLS_SCHEMA.complex LANGUAGE C IMMUTABLE STRICT 
	AS  'MODULE_PATHNAME','complex_pow';
COMMENT ON FUNCTION DSTOOLS_SCHEMA.complex_power(DSTOOLS_SCHEMA.complex, DSTOOLS_SCHEMA.complex)  IS 'exponentiation (x^y)';

CREATE FUNCTION DSTOOLS_SCHEMA.complex_sqrt(DSTOOLS_SCHEMA.complex) RETURNS DSTOOLS_SCHEMA.complex LANGUAGE C IMMUTABLE STRICT 
	AS  'MODULE_PATHNAME','complex_sqrt' ;
COMMENT ON FUNCTION DSTOOLS_SCHEMA.complex_sqrt(DSTOOLS_SCHEMA.complex)  IS 'squre root';

CREATE FUNCTION DSTOOLS_SCHEMA.complex_cbrt(DSTOOLS_SCHEMA.complex) RETURNS DSTOOLS_SCHEMA.complex LANGUAGE C IMMUTABLE STRICT 
	AS  'MODULE_PATHNAME','complex_cbrt' ;
COMMENT ON FUNCTION DSTOOLS_SCHEMA.complex_cbrt(DSTOOLS_SCHEMA.complex)  IS 'cube root';

CREATE FUNCTION DSTOOLS_SCHEMA.degrees(DSTOOLS_SCHEMA.complex) RETURNS float8 LANGUAGE C IMMUTABLE STRICT 
	AS  'MODULE_PATHNAME','complex_degrees';
COMMENT ON FUNCTION DSTOOLS_SCHEMA.degrees(DSTOOLS_SCHEMA.complex)  IS 'phase to degrees';

CREATE FUNCTION DSTOOLS_SCHEMA.exp(DSTOOLS_SCHEMA.complex) RETURNS DSTOOLS_SCHEMA.complex LANGUAGE C IMMUTABLE STRICT 
	AS  'MODULE_PATHNAME','complex_exp' ;
COMMENT ON FUNCTION DSTOOLS_SCHEMA.exp(DSTOOLS_SCHEMA.complex)  IS 'natural exponential (e^x)';

CREATE FUNCTION DSTOOLS_SCHEMA.ln(DSTOOLS_SCHEMA.complex) RETURNS DSTOOLS_SCHEMA.complex LANGUAGE C IMMUTABLE STRICT 
	AS  'MODULE_PATHNAME','complex_ln' ;
COMMENT ON FUNCTION DSTOOLS_SCHEMA.ln(DSTOOLS_SCHEMA.complex)  IS 'natural logarithm';

CREATE FUNCTION DSTOOLS_SCHEMA.log(DSTOOLS_SCHEMA.complex) RETURNS DSTOOLS_SCHEMA.complex LANGUAGE C IMMUTABLE STRICT 
	AS  'MODULE_PATHNAME','complex_log10' ;
COMMENT ON FUNCTION DSTOOLS_SCHEMA.log(DSTOOLS_SCHEMA.complex)  IS 'base 10 logarithm';

CREATE FUNCTION DSTOOLS_SCHEMA.log(DSTOOLS_SCHEMA.complex, DSTOOLS_SCHEMA.complex) RETURNS DSTOOLS_SCHEMA.complex LANGUAGE C IMMUTABLE STRICT 
	AS  'MODULE_PATHNAME','complex_log' ;
COMMENT ON FUNCTION DSTOOLS_SCHEMA.log(DSTOOLS_SCHEMA.complex, DSTOOLS_SCHEMA.complex)  IS 'logarithm base arg1 of arg2';

CREATE FUNCTION DSTOOLS_SCHEMA.acos(DSTOOLS_SCHEMA.complex) RETURNS DSTOOLS_SCHEMA.complex LANGUAGE C IMMUTABLE STRICT 
	AS  'MODULE_PATHNAME','complex_acos' ;
COMMENT ON FUNCTION DSTOOLS_SCHEMA.acos(DSTOOLS_SCHEMA.complex)  IS 'acos';

CREATE FUNCTION DSTOOLS_SCHEMA.asin(DSTOOLS_SCHEMA.complex) RETURNS DSTOOLS_SCHEMA.complex LANGUAGE C IMMUTABLE STRICT 
	AS  'MODULE_PATHNAME','complex_asin' ;
COMMENT ON FUNCTION DSTOOLS_SCHEMA.asin(DSTOOLS_SCHEMA.complex)  IS 'asin';

CREATE FUNCTION DSTOOLS_SCHEMA.atan(DSTOOLS_SCHEMA.complex) RETURNS DSTOOLS_SCHEMA.complex LANGUAGE C IMMUTABLE STRICT 
	AS  'MODULE_PATHNAME','complex_atan' ;
COMMENT ON FUNCTION DSTOOLS_SCHEMA.atan(DSTOOLS_SCHEMA.complex)  IS 'atan';

CREATE FUNCTION DSTOOLS_SCHEMA.cos(DSTOOLS_SCHEMA.complex) RETURNS DSTOOLS_SCHEMA.complex LANGUAGE C IMMUTABLE STRICT 
	AS  'MODULE_PATHNAME','complex_cos' ;
COMMENT ON FUNCTION DSTOOLS_SCHEMA.cos(DSTOOLS_SCHEMA.complex)  IS 'cos';

CREATE FUNCTION DSTOOLS_SCHEMA.cot(DSTOOLS_SCHEMA.complex) RETURNS DSTOOLS_SCHEMA.complex LANGUAGE C IMMUTABLE STRICT 
	AS  'MODULE_PATHNAME','complex_cot' ;
COMMENT ON FUNCTION DSTOOLS_SCHEMA.cot(DSTOOLS_SCHEMA.complex)  IS 'cot';

CREATE FUNCTION DSTOOLS_SCHEMA.sin(DSTOOLS_SCHEMA.complex) RETURNS DSTOOLS_SCHEMA.complex LANGUAGE C IMMUTABLE STRICT 
	AS  'MODULE_PATHNAME','complex_sin' ;
COMMENT ON FUNCTION DSTOOLS_SCHEMA.sin(DSTOOLS_SCHEMA.complex)  IS 'sin';

CREATE FUNCTION DSTOOLS_SCHEMA.tan(DSTOOLS_SCHEMA.complex) RETURNS DSTOOLS_SCHEMA.complex LANGUAGE C IMMUTABLE STRICT 
	AS  'MODULE_PATHNAME','complex_tan';
COMMENT ON FUNCTION DSTOOLS_SCHEMA.tan(DSTOOLS_SCHEMA.complex)  IS 'tan';

CREATE FUNCTION DSTOOLS_SCHEMA.dotproduct(DSTOOLS_SCHEMA.complex[], DSTOOLS_SCHEMA.complex[]) RETURNS DSTOOLS_SCHEMA.complex LANGUAGE C IMMUTABLE STRICT 
	AS  'MODULE_PATHNAME','complex_dot_product';
COMMENT ON FUNCTION DSTOOLS_SCHEMA.dotproduct(DSTOOLS_SCHEMA.complex[], DSTOOLS_SCHEMA.complex[])  IS 'dot product';

CREATE FUNCTION DSTOOLS_SCHEMA.float82complex(float8) RETURNS DSTOOLS_SCHEMA.complex LANGUAGE C IMMUTABLE STRICT 
	AS  'MODULE_PATHNAME','float82complex' ;
COMMENT ON FUNCTION DSTOOLS_SCHEMA.float82complex(float8)  IS '(internal) type cast from float8 to complex';

CREATE FUNCTION DSTOOLS_SCHEMA.float42complex(float4) RETURNS DSTOOLS_SCHEMA.complex LANGUAGE C IMMUTABLE STRICT 
	AS  'MODULE_PATHNAME','float42complex';
COMMENT ON FUNCTION DSTOOLS_SCHEMA.float42complex(float4)  IS '(internal) type cast from float4 to complex';

CREATE FUNCTION DSTOOLS_SCHEMA.int82complex(int8) RETURNS DSTOOLS_SCHEMA.complex LANGUAGE C IMMUTABLE STRICT 
	AS  'MODULE_PATHNAME','int82complex';
COMMENT ON FUNCTION DSTOOLS_SCHEMA.int82complex(int8)  IS '(internal) type cast from int8 to complex';

CREATE FUNCTION DSTOOLS_SCHEMA.int42complex(int4) RETURNS DSTOOLS_SCHEMA.complex LANGUAGE C IMMUTABLE STRICT 
	AS  'MODULE_PATHNAME','int42complex';
COMMENT ON FUNCTION DSTOOLS_SCHEMA.int42complex(int4)  IS '(internal) type cast from int4 to complex';

CREATE FUNCTION DSTOOLS_SCHEMA.int22complex(int2) RETURNS DSTOOLS_SCHEMA.complex LANGUAGE C IMMUTABLE STRICT 
	AS  'MODULE_PATHNAME','int22complex';
COMMENT ON FUNCTION DSTOOLS_SCHEMA.int22complex(int2)  IS '(internal) type cast from int2 to complex';


/*Overloaded power() function which accepts double as input*/
CREATE FUNCTION DSTOOLS_SCHEMA.power(x DSTOOLS_SCHEMA.complex, y float8) RETURNS DSTOOLS_SCHEMA.complex 
AS  
$$
    SELECT DSTOOLS_SCHEMA.complex_power($1, DSTOOLS_SCHEMA.complex($2,0));
$$ LANGUAGE SQL VOLATILE;
COMMENT ON FUNCTION DSTOOLS_SCHEMA.power(DSTOOLS_SCHEMA.complex, float8)  IS 'exponentiation (x^y)';

/*Overloaded complex_div function which accepts double as input */
CREATE FUNCTION DSTOOLS_SCHEMA.div(DSTOOLS_SCHEMA.complex, float8) RETURNS DSTOOLS_SCHEMA.complex LANGUAGE SQL VOLATILE 
	AS  
$$
        SELECT DSTOOLS_SCHEMA.complex_div($1, DSTOOLS_SCHEMA.COMPLEX($2,0));
$$ ;
COMMENT ON FUNCTION DSTOOLS_SCHEMA.div(DSTOOLS_SCHEMA.complex, float8)  IS 'divide';

/*Overloaded complex_div function which accepts double as input */
CREATE FUNCTION DSTOOLS_SCHEMA.div(float8, DSTOOLS_SCHEMA.complex) RETURNS DSTOOLS_SCHEMA.complex LANGUAGE SQL VOLATILE 
	AS  
$$
        SELECT DSTOOLS_SCHEMA.complex_div(DSTOOLS_SCHEMA.COMPLEX($1,0),$2);
$$ ;
COMMENT ON FUNCTION DSTOOLS_SCHEMA.div(float8, DSTOOLS_SCHEMA.complex)  IS 'divide';

/*Overloaded complex_mul function which accepts double as input*/
CREATE FUNCTION DSTOOLS_SCHEMA.mul(DSTOOLS_SCHEMA.complex, float8) RETURNS DSTOOLS_SCHEMA.complex LANGUAGE SQL VOLATILE 
	AS
$$
        SELECT DSTOOLS_SCHEMA.complex_mul($1,DSTOOLS_SCHEMA.complex($2,0));
$$;
COMMENT ON FUNCTION DSTOOLS_SCHEMA.mul(DSTOOLS_SCHEMA.complex, float8)  IS 'multiply';

/*Overloaded complex_mul function which accepts double as input*/
CREATE FUNCTION DSTOOLS_SCHEMA.mul(float8, DSTOOLS_SCHEMA.complex) RETURNS DSTOOLS_SCHEMA.complex LANGUAGE SQL VOLATILE 
	AS
$$
        SELECT DSTOOLS_SCHEMA.complex_mul(DSTOOLS_SCHEMA.complex($1,0), $2);
$$;
COMMENT ON FUNCTION DSTOOLS_SCHEMA.mul(float8, DSTOOLS_SCHEMA.complex)  IS 'multiply';

/* Overloaded complex_pl function which accepts double as input*/
CREATE FUNCTION DSTOOLS_SCHEMA.pl(DSTOOLS_SCHEMA.complex, float8) RETURNS DSTOOLS_SCHEMA.complex LANGUAGE SQL VOLATILE 
	AS
$$
        SELECT DSTOOLS_SCHEMA.complex_pl($1, DSTOOLS_SCHEMA.complex($2,0));
$$;
COMMENT ON FUNCTION DSTOOLS_SCHEMA.pl(DSTOOLS_SCHEMA.complex, float8)  IS 'plus';

/* Overloaded complex_pl function which accepts double as input*/
CREATE FUNCTION DSTOOLS_SCHEMA.pl(float8, DSTOOLS_SCHEMA.complex) RETURNS DSTOOLS_SCHEMA.complex LANGUAGE SQL VOLATILE 
	AS
$$
        SELECT DSTOOLS_SCHEMA.complex_pl(DSTOOLS_SCHEMA.complex($1,0),$2);
$$;
COMMENT ON FUNCTION DSTOOLS_SCHEMA.pl(float8, DSTOOLS_SCHEMA.complex)  IS 'plus';

/* Overloaded complex_mi function which accepts a double as input */
CREATE FUNCTION DSTOOLS_SCHEMA.mi(DSTOOLS_SCHEMA.complex, float8) RETURNS DSTOOLS_SCHEMA.complex LANGUAGE SQL VOLATILE
	AS
$$
        SELECT DSTOOLS_SCHEMA.complex_mi($1, DSTOOLS_SCHEMA.complex($2,0));
$$;
COMMENT ON FUNCTION DSTOOLS_SCHEMA.mi(DSTOOLS_SCHEMA.complex, float8)  IS 'minus';

/* Overloaded complex_mi function which accepts a double as input */
CREATE FUNCTION DSTOOLS_SCHEMA.mi(float8, DSTOOLS_SCHEMA.complex) RETURNS DSTOOLS_SCHEMA.complex LANGUAGE SQL VOLATILE
	AS
$$
        SELECT DSTOOLS_SCHEMA.complex_mi(DSTOOLS_SCHEMA.complex($1,0),$2);
$$;
COMMENT ON FUNCTION DSTOOLS_SCHEMA.mi(float8, DSTOOLS_SCHEMA.complex)  IS 'minus';


CREATE FUNCTION DSTOOLS_SCHEMA.sqrt(DSTOOLS_SCHEMA.complex) RETURNS DSTOOLS_SCHEMA.complex LANGUAGE C IMMUTABLE STRICT 
	AS  'MODULE_PATHNAME','complex_sqrt';
COMMENT ON FUNCTION DSTOOLS_SCHEMA.sqrt(DSTOOLS_SCHEMA.complex)  IS 'squre root';

CREATE FUNCTION DSTOOLS_SCHEMA.cbrt(DSTOOLS_SCHEMA.complex) RETURNS DSTOOLS_SCHEMA.complex LANGUAGE C IMMUTABLE STRICT 
	AS  'MODULE_PATHNAME','complex_cbrt' ;
COMMENT ON FUNCTION DSTOOLS_SCHEMA.cbrt(DSTOOLS_SCHEMA.complex)  IS 'cube root'; 

CREATE FUNCTION DSTOOLS_SCHEMA.numeric2point("numeric") RETURNS DSTOOLS_SCHEMA.complex LANGUAGE C IMMUTABLE STRICT 
	AS  'MODULE_PATHNAME','numeric2complex' ;
COMMENT ON FUNCTION DSTOOLS_SCHEMA.numeric2point("numeric")  IS '(internal) type cast from numeric to complex';


/**
 * Operators on Complex numbers
 */
CREATE OPERATOR DSTOOLS_SCHEMA.=	 (PROCEDURE = DSTOOLS_SCHEMA.complex_eq	,  LEFTARG=DSTOOLS_SCHEMA.complex , RIGHTARG = DSTOOLS_SCHEMA.complex,  RESTRICT=eqsel, JOIN=eqjoinsel);

CREATE OPERATOR DSTOOLS_SCHEMA.<> (PROCEDURE = DSTOOLS_SCHEMA.complex_ne	,  LEFTARG=DSTOOLS_SCHEMA.complex , RIGHTARG = DSTOOLS_SCHEMA.complex, RESTRICT=neqsel, NEGATOR = =, JOIN=neqjoinsel); 

CREATE OPERATOR DSTOOLS_SCHEMA.@	 (PROCEDURE = DSTOOLS_SCHEMA.complexabs	,  RIGHTARG = DSTOOLS_SCHEMA.complex); 

CREATE OPERATOR DSTOOLS_SCHEMA.+	 (PROCEDURE = DSTOOLS_SCHEMA.complex_pl	,  LEFTARG=DSTOOLS_SCHEMA.complex , RIGHTARG = DSTOOLS_SCHEMA.complex); 

CREATE OPERATOR DSTOOLS_SCHEMA.+	 (PROCEDURE = DSTOOLS_SCHEMA.complex_up	,  RIGHTARG = DSTOOLS_SCHEMA.complex); 

CREATE OPERATOR DSTOOLS_SCHEMA.+	 (PROCEDURE = DSTOOLS_SCHEMA.pl	,  LEFTARG=DSTOOLS_SCHEMA.complex, RIGHTARG = float8); 

CREATE OPERATOR DSTOOLS_SCHEMA.+	 (PROCEDURE = DSTOOLS_SCHEMA.pl	,  LEFTARG=float8, RIGHTARG=DSTOOLS_SCHEMA.complex); 

CREATE OPERATOR DSTOOLS_SCHEMA.-	 (PROCEDURE = DSTOOLS_SCHEMA.complex_mi	,  LEFTARG=DSTOOLS_SCHEMA.complex , RIGHTARG = DSTOOLS_SCHEMA.complex); 

CREATE OPERATOR DSTOOLS_SCHEMA.-	 (PROCEDURE = DSTOOLS_SCHEMA.complex_um	,  RIGHTARG = DSTOOLS_SCHEMA.complex); 

CREATE OPERATOR DSTOOLS_SCHEMA.-	 (PROCEDURE = DSTOOLS_SCHEMA.mi	,  LEFTARG=DSTOOLS_SCHEMA.complex, RIGHTARG = float8); 

CREATE OPERATOR DSTOOLS_SCHEMA.-	 (PROCEDURE = DSTOOLS_SCHEMA.mi	,  LEFTARG=float8, RIGHTARG = DSTOOLS_SCHEMA.complex); 

CREATE OPERATOR DSTOOLS_SCHEMA.*	 (PROCEDURE = DSTOOLS_SCHEMA.complex_mul   ,  LEFTARG=DSTOOLS_SCHEMA.complex , RIGHTARG = DSTOOLS_SCHEMA.complex);

CREATE OPERATOR DSTOOLS_SCHEMA.*	 (PROCEDURE = DSTOOLS_SCHEMA.mul   ,  LEFTARG=DSTOOLS_SCHEMA.complex , RIGHTARG = float8);

CREATE OPERATOR DSTOOLS_SCHEMA.*	 (PROCEDURE = DSTOOLS_SCHEMA.mul   ,  LEFTARG=float8 , RIGHTARG = DSTOOLS_SCHEMA.complex);

CREATE OPERATOR DSTOOLS_SCHEMA./	 (PROCEDURE = DSTOOLS_SCHEMA.complex_div   ,  LEFTARG=DSTOOLS_SCHEMA.complex , RIGHTARG = DSTOOLS_SCHEMA.complex);

CREATE OPERATOR DSTOOLS_SCHEMA./	 (PROCEDURE = DSTOOLS_SCHEMA.div   ,  LEFTARG=DSTOOLS_SCHEMA.complex , RIGHTARG = float8);

CREATE OPERATOR DSTOOLS_SCHEMA./	 (PROCEDURE = DSTOOLS_SCHEMA.div   ,  LEFTARG=float8 , RIGHTARG = DSTOOLS_SCHEMA.complex);

CREATE OPERATOR DSTOOLS_SCHEMA.^	 (PROCEDURE = DSTOOLS_SCHEMA.complex_power ,  LEFTARG=DSTOOLS_SCHEMA.complex , RIGHTARG = DSTOOLS_SCHEMA.complex);

CREATE OPERATOR DSTOOLS_SCHEMA.^	 (PROCEDURE = DSTOOLS_SCHEMA.power ,  LEFTARG=DSTOOLS_SCHEMA.complex , RIGHTARG = float8);

CREATE OPERATOR DSTOOLS_SCHEMA.|/ (PROCEDURE = DSTOOLS_SCHEMA.complex_sqrt  ,  RIGHTARG = DSTOOLS_SCHEMA.complex);

CREATE OPERATOR DSTOOLS_SCHEMA.||/  (PROCEDURE = DSTOOLS_SCHEMA.complex_cbrt  ,  RIGHTARG = DSTOOLS_SCHEMA.complex);	

