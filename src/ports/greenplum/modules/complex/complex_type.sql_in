/* ----------------------------------------------------------------------- *//**

@file complex_type.sql_in

@brief Implementation of a user-defined Complex type.

@author Written by Kevin Yun Liu. Adapted for PDL Tools by Srivatsan Ramanujam.
@date 1 Apr 2012

 *//* ----------------------------------------------------------------------- */

/**
@addtogroup grp_complex

@brief Implementation of a user-defined Complex type.

<div class="toc"><b>Contents</b>
<ul>
<li class="level1"><a href="#complex_usage">Usage</a>
</ul>
</div>

@about
A complex number is represented as \f$ a+b\text{i} \f$, where \a a and \a b
are double precision floating point numbers (\c FLOAT8) and represent that
number's real and imaginary part, respectively.

@anchor complex_usage
@usage
The following are functionalities enabled by the \c Complex type.
@verbatim
-- Constructors.
 SELECT COMPLEX(5,3);
 SELECT COMPLEX('5+3i');

-- Retrieving a complex number's real part.
SELECT re(COMPLEX(5, 3));

-- Retrieving a complex number's imaginary part.
SELECT im(COMPLEX(5, 3));

-- Absolute value.
SELECT abs(COMPLEX(4, 3)); 

-- Angle from the positive real line in radians.
SELECT radians(COMPLEX(1, sqrt(3)));

-- Complex conjugation.
SELECT conj(COMPLEX(5,3));

-- Unary plus.
SELECT +(COMPLEX(5, 3));

-- Unary minus.
SELECT -(COMPLEX(5, 3));

-- Addition.
SELECT COMPLEX(3, 5) + COMPLEX(6, 7);

-- Subtraction.
SELECT COMPLEX(3, 5) - COMPLEX(6, 7);

-- Multiplication.
SELECT COMPLEX(3, 5) * COMPLEX(6, 7);

-- Division.
SELECT COMPLEX(2,2)/COMPLEX(1,1);

-- @ (Shorthand for absolute value).
SELECT @(COMPLEX(5,3);

-- Exponentiation, using either "power" or "^".
SELECT COMPLEX(1,sqrt(3))^3;
SELECT power(COMPLEX(1,sqrt(3)),3);

-- Square root.
SELECT sqrt(COMPLEX(5,3));

-- Cubic root.
SELECT cbrt(COMPLEX(5,3));

-- Angle from the positive real line in degrees.
SELECT degrees(COMPLEX(5,3));

-- Exponent of a complex number.
SELECT exp(COMPLEX(5,3));

-- Natural logarithm.
SELECT ln(COMPLEX(5,3));

-- Base 10 logarithm.
SELECT log(COMPLEX(5,3));

-- Inverse cosine.
SELECT acos(COMPLEX(5,3));

-- Inverse sine.
SELECT asin(COMPLEX(5,3));

-- Inverse tangent.
SELECT atan(COMPLEX(5,3));

-- Cosine.
SELECT cos(COMPLEX(5,3));

-- Sine.
SELECT sin(COMPLEX(5,3));

-- Cotangent.
SELECT cot(COMPLEX(5,3));

-- Tangent.
SELECT tan(COMPLEX(5,3));

-- Type cast.
SELECT COMPLEX '5+3i' ^ '4'::int2;

-- Dot product.
SELECT dotproduct(ARRAY[COMPLEX(1,3),COMPLEX(5,7)], ARRAY[COMPLEX(2,4),COMPLEX(6,8)]);
@endverbatim

@warning Though the complex type is useful for calculations, when storing values in a table for long-term storage it is preferable to convert the values back to native database types. The reason for this is that when the library is upgraded, columns of user-defined types such as "complex" are not upgraded with it.

@note Like all other PDL Tools utilities, the complex data type is defined
within the PDL Tools schema.

@warning The '@' operator is a standard PostgreSQL operator signifying absolute
value. Note, however, that its usage conflicts with the '@' SUgAR operator.
When using SUgAR, opt for \c 'abs', instead.
 */

CREATE TYPE PDLTOOLS_SCHEMA.complex;

CREATE OR REPLACE FUNCTION PDLTOOLS_SCHEMA.complex_in(cstring) RETURNS PDLTOOLS_SCHEMA.complex LANGUAGE C IMMUTABLE STRICT 
	AS  'MODULE_PATHNAME','complex_in';
COMMENT ON FUNCTION PDLTOOLS_SCHEMA.complex_in(cstring)  IS 'IO';

CREATE OR REPLACE FUNCTION PDLTOOLS_SCHEMA.complex_out(PDLTOOLS_SCHEMA.complex) RETURNS cstring LANGUAGE C IMMUTABLE STRICT 
	AS  'MODULE_PATHNAME','complex_out';
COMMENT ON FUNCTION PDLTOOLS_SCHEMA.complex_out(PDLTOOLS_SCHEMA.complex)  IS 'IO';

CREATE OR REPLACE FUNCTION PDLTOOLS_SCHEMA.complex_recv(internal) RETURNS PDLTOOLS_SCHEMA.complex LANGUAGE C IMMUTABLE STRICT 
	AS  'MODULE_PATHNAME','complex_recv';
COMMENT ON FUNCTION PDLTOOLS_SCHEMA.complex_recv(internal)  IS 'IO';

CREATE OR REPLACE FUNCTION PDLTOOLS_SCHEMA.complex_send(PDLTOOLS_SCHEMA.complex) RETURNS bytea LANGUAGE C IMMUTABLE STRICT 
	AS  'MODULE_PATHNAME','complex_send' ;
COMMENT ON FUNCTION PDLTOOLS_SCHEMA.complex_send(PDLTOOLS_SCHEMA.complex)  IS 'IO';

CREATE TYPE PDLTOOLS_SCHEMA.complex(
   INPUT = PDLTOOLS_SCHEMA.complex_in,
   OUTPUT = PDLTOOLS_SCHEMA.complex_out,
   RECEIVE = PDLTOOLS_SCHEMA.complex_recv,
   SEND = PDLTOOLS_SCHEMA.complex_send,
   INTERNALLENGTH = 16,
   STORAGE = plain,
   ALIGNMENT = double
);
COMMENT ON TYPE PDLTOOLS_SCHEMA.complex IS 'double-precision floating point complex number, 16-byte storage';

---------------------------------------------------------------
-- Constructors and Operators on Complex Numbers
----------------------------------------------------------------

CREATE OR REPLACE FUNCTION PDLTOOLS_SCHEMA.complex(re float8, im float8) RETURNS PDLTOOLS_SCHEMA.complex LANGUAGE C IMMUTABLE STRICT
AS  'MODULE_PATHNAME','construct_complex'; 
COMMENT ON FUNCTION PDLTOOLS_SCHEMA.complex(float8, float8)  IS 'constructs a complex number with given magnitude and phase';

CREATE OR REPLACE FUNCTION PDLTOOLS_SCHEMA.complex_trig(re float8, im float8) RETURNS PDLTOOLS_SCHEMA.complex LANGUAGE C IMMUTABLE STRICT 
	AS  'MODULE_PATHNAME','construct_complex_trig';
COMMENT ON FUNCTION PDLTOOLS_SCHEMA.complex_trig(float8, float8)  IS 'constructs a complex number with given magnitude and phase';

CREATE OR REPLACE FUNCTION PDLTOOLS_SCHEMA.re(cmplx PDLTOOLS_SCHEMA.complex) RETURNS float8 LANGUAGE C IMMUTABLE STRICT 
	AS  'MODULE_PATHNAME','complex_re' ;
COMMENT ON FUNCTION PDLTOOLS_SCHEMA.re(PDLTOOLS_SCHEMA.complex)  IS 'returns the real part of the argument';

CREATE OR REPLACE FUNCTION PDLTOOLS_SCHEMA.im(cmplx PDLTOOLS_SCHEMA.complex) RETURNS float8 LANGUAGE C IMMUTABLE STRICT 
	AS  'MODULE_PATHNAME','complex_im';
COMMENT ON FUNCTION PDLTOOLS_SCHEMA.im(PDLTOOLS_SCHEMA.complex)  IS 'returns the imaginary part of the argument';

CREATE OR REPLACE FUNCTION PDLTOOLS_SCHEMA.radians(cmplx PDLTOOLS_SCHEMA.complex) RETURNS float8 LANGUAGE C IMMUTABLE STRICT 
	AS  'MODULE_PATHNAME','complex_arg' ;
COMMENT ON FUNCTION PDLTOOLS_SCHEMA.radians(PDLTOOLS_SCHEMA.complex)  IS 'returns the phase of the argument';

CREATE OR REPLACE FUNCTION PDLTOOLS_SCHEMA.complexabs(cmplx PDLTOOLS_SCHEMA.complex) RETURNS float8 LANGUAGE C IMMUTABLE STRICT 
	AS  'MODULE_PATHNAME','complex_mag' ;
COMMENT ON FUNCTION PDLTOOLS_SCHEMA.complexabs(PDLTOOLS_SCHEMA.complex)  IS 'returns the magnitude of the argument';

CREATE OR REPLACE FUNCTION PDLTOOLS_SCHEMA.abs(cmplx PDLTOOLS_SCHEMA.complex) RETURNS float8 LANGUAGE C IMMUTABLE STRICT 
	AS  'MODULE_PATHNAME','complex_mag';
COMMENT ON FUNCTION PDLTOOLS_SCHEMA.abs(PDLTOOLS_SCHEMA.complex)  IS 'returns the magnitude of the argument';

CREATE OR REPLACE FUNCTION PDLTOOLS_SCHEMA.conj(cmplx PDLTOOLS_SCHEMA.complex) RETURNS PDLTOOLS_SCHEMA.complex LANGUAGE C IMMUTABLE STRICT 
	AS  'MODULE_PATHNAME','complex_conj' ;
COMMENT ON FUNCTION PDLTOOLS_SCHEMA.conj(PDLTOOLS_SCHEMA.complex)  IS 'returns the conjunction of the argument';

CREATE OR REPLACE FUNCTION PDLTOOLS_SCHEMA.complex_eq(cmplx_a PDLTOOLS_SCHEMA.complex, cmplx_b PDLTOOLS_SCHEMA.complex) RETURNS bool  LANGUAGE C IMMUTABLE STRICT 
	AS  'MODULE_PATHNAME','complex_eq' ;
COMMENT ON FUNCTION PDLTOOLS_SCHEMA.complex_eq(PDLTOOLS_SCHEMA.complex, PDLTOOLS_SCHEMA.complex)  IS 'equal';

CREATE OR REPLACE FUNCTION PDLTOOLS_SCHEMA.complex_ne(PDLTOOLS_SCHEMA.complex, PDLTOOLS_SCHEMA.complex) RETURNS bool  LANGUAGE C IMMUTABLE STRICT 
	AS  'MODULE_PATHNAME','complex_ne';
COMMENT ON FUNCTION PDLTOOLS_SCHEMA.complex_ne(PDLTOOLS_SCHEMA.complex, PDLTOOLS_SCHEMA.complex)  IS 'not equal';

CREATE OR REPLACE FUNCTION PDLTOOLS_SCHEMA.complex_pl(PDLTOOLS_SCHEMA.complex, PDLTOOLS_SCHEMA.complex) RETURNS PDLTOOLS_SCHEMA.complex LANGUAGE C IMMUTABLE STRICT 
	AS  'MODULE_PATHNAME','complex_pl';
COMMENT ON FUNCTION PDLTOOLS_SCHEMA.complex_pl(PDLTOOLS_SCHEMA.complex, PDLTOOLS_SCHEMA.complex)  IS 'plus';

CREATE OR REPLACE FUNCTION PDLTOOLS_SCHEMA.complex_up(PDLTOOLS_SCHEMA.complex) RETURNS PDLTOOLS_SCHEMA.complex LANGUAGE C IMMUTABLE STRICT 
	AS  'MODULE_PATHNAME','complex_up';
COMMENT ON FUNCTION PDLTOOLS_SCHEMA.complex_up(PDLTOOLS_SCHEMA.complex)  IS 'unary plus';

CREATE OR REPLACE FUNCTION PDLTOOLS_SCHEMA.complex_mi(PDLTOOLS_SCHEMA.complex, PDLTOOLS_SCHEMA.complex) RETURNS PDLTOOLS_SCHEMA.complex LANGUAGE C IMMUTABLE STRICT 
	AS  'MODULE_PATHNAME','complex_mi' ;
COMMENT ON FUNCTION PDLTOOLS_SCHEMA.complex_mi(PDLTOOLS_SCHEMA.complex, PDLTOOLS_SCHEMA.complex)  IS 'minus';

CREATE OR REPLACE FUNCTION PDLTOOLS_SCHEMA.complex_um(PDLTOOLS_SCHEMA.complex) RETURNS PDLTOOLS_SCHEMA.complex LANGUAGE C IMMUTABLE STRICT 
	AS  'MODULE_PATHNAME','complex_um';
COMMENT ON FUNCTION PDLTOOLS_SCHEMA.complex_um(PDLTOOLS_SCHEMA.complex)  IS 'unary minus';

CREATE OR REPLACE FUNCTION PDLTOOLS_SCHEMA.complex_mul(PDLTOOLS_SCHEMA.complex, PDLTOOLS_SCHEMA.complex) RETURNS PDLTOOLS_SCHEMA.complex LANGUAGE C IMMUTABLE STRICT 
	AS  'MODULE_PATHNAME','complex_mul';
COMMENT ON FUNCTION PDLTOOLS_SCHEMA.complex_mul(PDLTOOLS_SCHEMA.complex, PDLTOOLS_SCHEMA.complex)  IS 'multiply';

CREATE OR REPLACE FUNCTION PDLTOOLS_SCHEMA.complex_div(PDLTOOLS_SCHEMA.complex, PDLTOOLS_SCHEMA.complex) RETURNS PDLTOOLS_SCHEMA.complex LANGUAGE C IMMUTABLE STRICT 
	AS  'MODULE_PATHNAME','complex_div';
COMMENT ON FUNCTION PDLTOOLS_SCHEMA.complex_div(PDLTOOLS_SCHEMA.complex, PDLTOOLS_SCHEMA.complex)  IS 'divide';

CREATE OR REPLACE FUNCTION PDLTOOLS_SCHEMA.complex_power(PDLTOOLS_SCHEMA.complex, PDLTOOLS_SCHEMA.complex) RETURNS PDLTOOLS_SCHEMA.complex LANGUAGE C IMMUTABLE STRICT 
	AS  'MODULE_PATHNAME','complex_pow';
COMMENT ON FUNCTION PDLTOOLS_SCHEMA.complex_power(PDLTOOLS_SCHEMA.complex, PDLTOOLS_SCHEMA.complex)  IS 'exponentiation (x^y)';

CREATE OR REPLACE FUNCTION PDLTOOLS_SCHEMA.complex_sqrt(PDLTOOLS_SCHEMA.complex) RETURNS PDLTOOLS_SCHEMA.complex LANGUAGE C IMMUTABLE STRICT 
	AS  'MODULE_PATHNAME','complex_sqrt' ;
COMMENT ON FUNCTION PDLTOOLS_SCHEMA.complex_sqrt(PDLTOOLS_SCHEMA.complex)  IS 'squre root';

CREATE OR REPLACE FUNCTION PDLTOOLS_SCHEMA.complex_cbrt(PDLTOOLS_SCHEMA.complex) RETURNS PDLTOOLS_SCHEMA.complex LANGUAGE C IMMUTABLE STRICT 
	AS  'MODULE_PATHNAME','complex_cbrt' ;
COMMENT ON FUNCTION PDLTOOLS_SCHEMA.complex_cbrt(PDLTOOLS_SCHEMA.complex)  IS 'cube root';

CREATE OR REPLACE FUNCTION PDLTOOLS_SCHEMA.degrees(PDLTOOLS_SCHEMA.complex) RETURNS float8 LANGUAGE C IMMUTABLE STRICT 
	AS  'MODULE_PATHNAME','complex_degrees';
COMMENT ON FUNCTION PDLTOOLS_SCHEMA.degrees(PDLTOOLS_SCHEMA.complex)  IS 'phase to degrees';

CREATE OR REPLACE FUNCTION PDLTOOLS_SCHEMA.exp(PDLTOOLS_SCHEMA.complex) RETURNS PDLTOOLS_SCHEMA.complex LANGUAGE C IMMUTABLE STRICT 
	AS  'MODULE_PATHNAME','complex_exp' ;
COMMENT ON FUNCTION PDLTOOLS_SCHEMA.exp(PDLTOOLS_SCHEMA.complex)  IS 'natural exponential (e^x)';

CREATE OR REPLACE FUNCTION PDLTOOLS_SCHEMA.ln(PDLTOOLS_SCHEMA.complex) RETURNS PDLTOOLS_SCHEMA.complex LANGUAGE C IMMUTABLE STRICT 
	AS  'MODULE_PATHNAME','complex_ln' ;
COMMENT ON FUNCTION PDLTOOLS_SCHEMA.ln(PDLTOOLS_SCHEMA.complex)  IS 'natural logarithm';

CREATE OR REPLACE FUNCTION PDLTOOLS_SCHEMA.log(PDLTOOLS_SCHEMA.complex) RETURNS PDLTOOLS_SCHEMA.complex LANGUAGE C IMMUTABLE STRICT 
	AS  'MODULE_PATHNAME','complex_log10' ;
COMMENT ON FUNCTION PDLTOOLS_SCHEMA.log(PDLTOOLS_SCHEMA.complex)  IS 'base 10 logarithm';

CREATE OR REPLACE FUNCTION PDLTOOLS_SCHEMA.log(PDLTOOLS_SCHEMA.complex, PDLTOOLS_SCHEMA.complex) RETURNS PDLTOOLS_SCHEMA.complex LANGUAGE C IMMUTABLE STRICT 
	AS  'MODULE_PATHNAME','complex_log' ;
COMMENT ON FUNCTION PDLTOOLS_SCHEMA.log(PDLTOOLS_SCHEMA.complex, PDLTOOLS_SCHEMA.complex)  IS 'logarithm base arg1 of arg2';

CREATE OR REPLACE FUNCTION PDLTOOLS_SCHEMA.acos(PDLTOOLS_SCHEMA.complex) RETURNS PDLTOOLS_SCHEMA.complex LANGUAGE C IMMUTABLE STRICT 
	AS  'MODULE_PATHNAME','complex_acos' ;
COMMENT ON FUNCTION PDLTOOLS_SCHEMA.acos(PDLTOOLS_SCHEMA.complex)  IS 'acos';

CREATE OR REPLACE FUNCTION PDLTOOLS_SCHEMA.asin(PDLTOOLS_SCHEMA.complex) RETURNS PDLTOOLS_SCHEMA.complex LANGUAGE C IMMUTABLE STRICT 
	AS  'MODULE_PATHNAME','complex_asin' ;
COMMENT ON FUNCTION PDLTOOLS_SCHEMA.asin(PDLTOOLS_SCHEMA.complex)  IS 'asin';

CREATE OR REPLACE FUNCTION PDLTOOLS_SCHEMA.atan(PDLTOOLS_SCHEMA.complex) RETURNS PDLTOOLS_SCHEMA.complex LANGUAGE C IMMUTABLE STRICT 
	AS  'MODULE_PATHNAME','complex_atan' ;
COMMENT ON FUNCTION PDLTOOLS_SCHEMA.atan(PDLTOOLS_SCHEMA.complex)  IS 'atan';

CREATE OR REPLACE FUNCTION PDLTOOLS_SCHEMA.cos(PDLTOOLS_SCHEMA.complex) RETURNS PDLTOOLS_SCHEMA.complex LANGUAGE C IMMUTABLE STRICT 
	AS  'MODULE_PATHNAME','complex_cos' ;
COMMENT ON FUNCTION PDLTOOLS_SCHEMA.cos(PDLTOOLS_SCHEMA.complex)  IS 'cos';

CREATE OR REPLACE FUNCTION PDLTOOLS_SCHEMA.cot(PDLTOOLS_SCHEMA.complex) RETURNS PDLTOOLS_SCHEMA.complex LANGUAGE C IMMUTABLE STRICT 
	AS  'MODULE_PATHNAME','complex_cot' ;
COMMENT ON FUNCTION PDLTOOLS_SCHEMA.cot(PDLTOOLS_SCHEMA.complex)  IS 'cot';

CREATE OR REPLACE FUNCTION PDLTOOLS_SCHEMA.sin(PDLTOOLS_SCHEMA.complex) RETURNS PDLTOOLS_SCHEMA.complex LANGUAGE C IMMUTABLE STRICT 
	AS  'MODULE_PATHNAME','complex_sin' ;
COMMENT ON FUNCTION PDLTOOLS_SCHEMA.sin(PDLTOOLS_SCHEMA.complex)  IS 'sin';

CREATE OR REPLACE FUNCTION PDLTOOLS_SCHEMA.tan(PDLTOOLS_SCHEMA.complex) RETURNS PDLTOOLS_SCHEMA.complex LANGUAGE C IMMUTABLE STRICT 
	AS  'MODULE_PATHNAME','complex_tan';
COMMENT ON FUNCTION PDLTOOLS_SCHEMA.tan(PDLTOOLS_SCHEMA.complex)  IS 'tan';

CREATE OR REPLACE FUNCTION PDLTOOLS_SCHEMA.dotproduct(PDLTOOLS_SCHEMA.complex[], PDLTOOLS_SCHEMA.complex[]) RETURNS PDLTOOLS_SCHEMA.complex LANGUAGE C IMMUTABLE STRICT 
	AS  'MODULE_PATHNAME','complex_dot_product';
COMMENT ON FUNCTION PDLTOOLS_SCHEMA.dotproduct(PDLTOOLS_SCHEMA.complex[], PDLTOOLS_SCHEMA.complex[])  IS 'dot product';

CREATE OR REPLACE FUNCTION PDLTOOLS_SCHEMA.float82complex(float8) RETURNS PDLTOOLS_SCHEMA.complex LANGUAGE C IMMUTABLE STRICT 
	AS  'MODULE_PATHNAME','float82complex' ;
COMMENT ON FUNCTION PDLTOOLS_SCHEMA.float82complex(float8)  IS '(internal) type cast from float8 to complex';

CREATE OR REPLACE FUNCTION PDLTOOLS_SCHEMA.float42complex(float4) RETURNS PDLTOOLS_SCHEMA.complex LANGUAGE C IMMUTABLE STRICT 
	AS  'MODULE_PATHNAME','float42complex';
COMMENT ON FUNCTION PDLTOOLS_SCHEMA.float42complex(float4)  IS '(internal) type cast from float4 to complex';

CREATE OR REPLACE FUNCTION PDLTOOLS_SCHEMA.int82complex(int8) RETURNS PDLTOOLS_SCHEMA.complex LANGUAGE C IMMUTABLE STRICT 
	AS  'MODULE_PATHNAME','int82complex';
COMMENT ON FUNCTION PDLTOOLS_SCHEMA.int82complex(int8)  IS '(internal) type cast from int8 to complex';

CREATE OR REPLACE FUNCTION PDLTOOLS_SCHEMA.int42complex(int4) RETURNS PDLTOOLS_SCHEMA.complex LANGUAGE C IMMUTABLE STRICT 
	AS  'MODULE_PATHNAME','int42complex';
COMMENT ON FUNCTION PDLTOOLS_SCHEMA.int42complex(int4)  IS '(internal) type cast from int4 to complex';

CREATE OR REPLACE FUNCTION PDLTOOLS_SCHEMA.int22complex(int2) RETURNS PDLTOOLS_SCHEMA.complex LANGUAGE C IMMUTABLE STRICT 
	AS  'MODULE_PATHNAME','int22complex';
COMMENT ON FUNCTION PDLTOOLS_SCHEMA.int22complex(int2)  IS '(internal) type cast from int2 to complex';


/*Overloaded power() function which accepts double as input*/
CREATE OR REPLACE FUNCTION PDLTOOLS_SCHEMA.power(x PDLTOOLS_SCHEMA.complex, y float8) RETURNS PDLTOOLS_SCHEMA.complex 
AS  
$$
    SELECT PDLTOOLS_SCHEMA.complex_power($1, PDLTOOLS_SCHEMA.complex($2,0));
$$ LANGUAGE SQL VOLATILE;
COMMENT ON FUNCTION PDLTOOLS_SCHEMA.power(PDLTOOLS_SCHEMA.complex, float8)  IS 'exponentiation (x^y)';

/*Overloaded complex_div function which accepts double as input */
CREATE OR REPLACE FUNCTION PDLTOOLS_SCHEMA.div(PDLTOOLS_SCHEMA.complex, float8) RETURNS PDLTOOLS_SCHEMA.complex LANGUAGE SQL VOLATILE 
	AS  
$$
        SELECT PDLTOOLS_SCHEMA.complex_div($1, PDLTOOLS_SCHEMA.COMPLEX($2,0));
$$ ;
COMMENT ON FUNCTION PDLTOOLS_SCHEMA.div(PDLTOOLS_SCHEMA.complex, float8)  IS 'divide';

/*Overloaded complex_div function which accepts double as input */
CREATE OR REPLACE FUNCTION PDLTOOLS_SCHEMA.div(float8, PDLTOOLS_SCHEMA.complex) RETURNS PDLTOOLS_SCHEMA.complex LANGUAGE SQL VOLATILE 
	AS  
$$
        SELECT PDLTOOLS_SCHEMA.complex_div(PDLTOOLS_SCHEMA.COMPLEX($1,0),$2);
$$ ;
COMMENT ON FUNCTION PDLTOOLS_SCHEMA.div(float8, PDLTOOLS_SCHEMA.complex)  IS 'divide';

/*Overloaded complex_mul function which accepts double as input*/
CREATE OR REPLACE FUNCTION PDLTOOLS_SCHEMA.mul(PDLTOOLS_SCHEMA.complex, float8) RETURNS PDLTOOLS_SCHEMA.complex LANGUAGE SQL VOLATILE 
	AS
$$
        SELECT PDLTOOLS_SCHEMA.complex_mul($1,PDLTOOLS_SCHEMA.complex($2,0));
$$;
COMMENT ON FUNCTION PDLTOOLS_SCHEMA.mul(PDLTOOLS_SCHEMA.complex, float8)  IS 'multiply';

/*Overloaded complex_mul function which accepts double as input*/
CREATE OR REPLACE FUNCTION PDLTOOLS_SCHEMA.mul(float8, PDLTOOLS_SCHEMA.complex) RETURNS PDLTOOLS_SCHEMA.complex LANGUAGE SQL VOLATILE 
	AS
$$
        SELECT PDLTOOLS_SCHEMA.complex_mul(PDLTOOLS_SCHEMA.complex($1,0), $2);
$$;
COMMENT ON FUNCTION PDLTOOLS_SCHEMA.mul(float8, PDLTOOLS_SCHEMA.complex)  IS 'multiply';

/* Overloaded complex_pl function which accepts double as input*/
CREATE OR REPLACE FUNCTION PDLTOOLS_SCHEMA.pl(PDLTOOLS_SCHEMA.complex, float8) RETURNS PDLTOOLS_SCHEMA.complex LANGUAGE SQL VOLATILE 
	AS
$$
        SELECT PDLTOOLS_SCHEMA.complex_pl($1, PDLTOOLS_SCHEMA.complex($2,0));
$$;
COMMENT ON FUNCTION PDLTOOLS_SCHEMA.pl(PDLTOOLS_SCHEMA.complex, float8)  IS 'plus';

/* Overloaded complex_pl function which accepts double as input*/
CREATE OR REPLACE FUNCTION PDLTOOLS_SCHEMA.pl(float8, PDLTOOLS_SCHEMA.complex) RETURNS PDLTOOLS_SCHEMA.complex LANGUAGE SQL VOLATILE 
	AS
$$
        SELECT PDLTOOLS_SCHEMA.complex_pl(PDLTOOLS_SCHEMA.complex($1,0),$2);
$$;
COMMENT ON FUNCTION PDLTOOLS_SCHEMA.pl(float8, PDLTOOLS_SCHEMA.complex)  IS 'plus';

/* Overloaded complex_mi function which accepts a double as input */
CREATE OR REPLACE FUNCTION PDLTOOLS_SCHEMA.mi(PDLTOOLS_SCHEMA.complex, float8) RETURNS PDLTOOLS_SCHEMA.complex LANGUAGE SQL VOLATILE
	AS
$$
        SELECT PDLTOOLS_SCHEMA.complex_mi($1, PDLTOOLS_SCHEMA.complex($2,0));
$$;
COMMENT ON FUNCTION PDLTOOLS_SCHEMA.mi(PDLTOOLS_SCHEMA.complex, float8)  IS 'minus';

/* Overloaded complex_mi function which accepts a double as input */
CREATE OR REPLACE FUNCTION PDLTOOLS_SCHEMA.mi(float8, PDLTOOLS_SCHEMA.complex) RETURNS PDLTOOLS_SCHEMA.complex LANGUAGE SQL VOLATILE
	AS
$$
        SELECT PDLTOOLS_SCHEMA.complex_mi(PDLTOOLS_SCHEMA.complex($1,0),$2);
$$;
COMMENT ON FUNCTION PDLTOOLS_SCHEMA.mi(float8, PDLTOOLS_SCHEMA.complex)  IS 'minus';


CREATE OR REPLACE FUNCTION PDLTOOLS_SCHEMA.sqrt(PDLTOOLS_SCHEMA.complex) RETURNS PDLTOOLS_SCHEMA.complex LANGUAGE C IMMUTABLE STRICT 
	AS  'MODULE_PATHNAME','complex_sqrt';
COMMENT ON FUNCTION PDLTOOLS_SCHEMA.sqrt(PDLTOOLS_SCHEMA.complex)  IS 'squre root';

CREATE OR REPLACE FUNCTION PDLTOOLS_SCHEMA.cbrt(PDLTOOLS_SCHEMA.complex) RETURNS PDLTOOLS_SCHEMA.complex LANGUAGE C IMMUTABLE STRICT 
	AS  'MODULE_PATHNAME','complex_cbrt' ;
COMMENT ON FUNCTION PDLTOOLS_SCHEMA.cbrt(PDLTOOLS_SCHEMA.complex)  IS 'cube root'; 

CREATE OR REPLACE FUNCTION PDLTOOLS_SCHEMA.numeric2point("numeric") RETURNS PDLTOOLS_SCHEMA.complex LANGUAGE C IMMUTABLE STRICT 
	AS  'MODULE_PATHNAME','numeric2complex' ;
COMMENT ON FUNCTION PDLTOOLS_SCHEMA.numeric2point("numeric")  IS '(internal) type cast from numeric to complex';


/*
 Operators on Complex numbers
 */
CREATE OPERATOR PDLTOOLS_SCHEMA.=	 (PROCEDURE = PDLTOOLS_SCHEMA.complex_eq	,  LEFTARG=PDLTOOLS_SCHEMA.complex , RIGHTARG = PDLTOOLS_SCHEMA.complex,  RESTRICT=eqsel, JOIN=eqjoinsel);

CREATE OPERATOR PDLTOOLS_SCHEMA.<> (PROCEDURE = PDLTOOLS_SCHEMA.complex_ne	,  LEFTARG=PDLTOOLS_SCHEMA.complex , RIGHTARG = PDLTOOLS_SCHEMA.complex, RESTRICT=neqsel, NEGATOR = OPERATOR(PDLTOOLS_SCHEMA.=), JOIN=neqjoinsel); 

CREATE OPERATOR PDLTOOLS_SCHEMA.@	 (PROCEDURE = PDLTOOLS_SCHEMA.complexabs	,  RIGHTARG = PDLTOOLS_SCHEMA.complex); 

CREATE OPERATOR PDLTOOLS_SCHEMA.+	 (PROCEDURE = PDLTOOLS_SCHEMA.complex_pl	,  LEFTARG=PDLTOOLS_SCHEMA.complex , RIGHTARG = PDLTOOLS_SCHEMA.complex); 

CREATE OPERATOR PDLTOOLS_SCHEMA.+	 (PROCEDURE = PDLTOOLS_SCHEMA.complex_up	,  RIGHTARG = PDLTOOLS_SCHEMA.complex); 

CREATE OPERATOR PDLTOOLS_SCHEMA.+	 (PROCEDURE = PDLTOOLS_SCHEMA.pl	,  LEFTARG=PDLTOOLS_SCHEMA.complex, RIGHTARG = float8); 

CREATE OPERATOR PDLTOOLS_SCHEMA.+	 (PROCEDURE = PDLTOOLS_SCHEMA.pl	,  LEFTARG=float8, RIGHTARG=PDLTOOLS_SCHEMA.complex); 

CREATE OPERATOR PDLTOOLS_SCHEMA.-	 (PROCEDURE = PDLTOOLS_SCHEMA.complex_mi	,  LEFTARG=PDLTOOLS_SCHEMA.complex , RIGHTARG = PDLTOOLS_SCHEMA.complex); 

CREATE OPERATOR PDLTOOLS_SCHEMA.-	 (PROCEDURE = PDLTOOLS_SCHEMA.complex_um	,  RIGHTARG = PDLTOOLS_SCHEMA.complex); 

CREATE OPERATOR PDLTOOLS_SCHEMA.-	 (PROCEDURE = PDLTOOLS_SCHEMA.mi	,  LEFTARG=PDLTOOLS_SCHEMA.complex, RIGHTARG = float8); 

CREATE OPERATOR PDLTOOLS_SCHEMA.-	 (PROCEDURE = PDLTOOLS_SCHEMA.mi	,  LEFTARG=float8, RIGHTARG = PDLTOOLS_SCHEMA.complex); 

CREATE OPERATOR PDLTOOLS_SCHEMA.*	 (PROCEDURE = PDLTOOLS_SCHEMA.complex_mul   ,  LEFTARG=PDLTOOLS_SCHEMA.complex , RIGHTARG = PDLTOOLS_SCHEMA.complex);

CREATE OPERATOR PDLTOOLS_SCHEMA.*	 (PROCEDURE = PDLTOOLS_SCHEMA.mul   ,  LEFTARG=PDLTOOLS_SCHEMA.complex , RIGHTARG = float8);

CREATE OPERATOR PDLTOOLS_SCHEMA.*	 (PROCEDURE = PDLTOOLS_SCHEMA.mul   ,  LEFTARG=float8 , RIGHTARG = PDLTOOLS_SCHEMA.complex);

CREATE OPERATOR PDLTOOLS_SCHEMA./	 (PROCEDURE = PDLTOOLS_SCHEMA.complex_div   ,  LEFTARG=PDLTOOLS_SCHEMA.complex , RIGHTARG = PDLTOOLS_SCHEMA.complex);

CREATE OPERATOR PDLTOOLS_SCHEMA./	 (PROCEDURE = PDLTOOLS_SCHEMA.div   ,  LEFTARG=PDLTOOLS_SCHEMA.complex , RIGHTARG = float8);

CREATE OPERATOR PDLTOOLS_SCHEMA./	 (PROCEDURE = PDLTOOLS_SCHEMA.div   ,  LEFTARG=float8 , RIGHTARG = PDLTOOLS_SCHEMA.complex);

CREATE OPERATOR PDLTOOLS_SCHEMA.^	 (PROCEDURE = PDLTOOLS_SCHEMA.complex_power ,  LEFTARG=PDLTOOLS_SCHEMA.complex , RIGHTARG = PDLTOOLS_SCHEMA.complex);

CREATE OPERATOR PDLTOOLS_SCHEMA.^	 (PROCEDURE = PDLTOOLS_SCHEMA.power ,  LEFTARG=PDLTOOLS_SCHEMA.complex , RIGHTARG = float8);

CREATE OPERATOR PDLTOOLS_SCHEMA.|/ (PROCEDURE = PDLTOOLS_SCHEMA.complex_sqrt  ,  RIGHTARG = PDLTOOLS_SCHEMA.complex);

CREATE OPERATOR PDLTOOLS_SCHEMA.||/  (PROCEDURE = PDLTOOLS_SCHEMA.complex_cbrt  ,  RIGHTARG = PDLTOOLS_SCHEMA.complex);	

